#!/usr/bin/env python3
"""Agent Fuzzer CLI Addon - Security validation through parameter-aware fuzzing.

This addon extends the Agent Interrogator CLI tool with fuzzing capabilities.
It consumes AgentProfile output (JSON format) and systematically fuzzes discovered
MCP server functions to identify validation flaws, logic errors, and Excessive
Agency vulnerabilities.

FEATURES:
- Consumes AgentProfile JSON files from Agent Interrogator
- Parameter-aware payload generation based on type and context
- Non-destructive fuzzing by default (safe for production testing)
- Rate limiting to avoid detection
- Detailed vulnerability reporting in JSON and Markdown

USAGE:
    # Fuzz using existing AgentProfile
    python agent_fuzzer_cli_addon.py --profile agent-profile-example.com.json --target https://example.com/mcp

    # Generate profile and fuzz in one command (use main CLI with --fuzz flag)
    python agent-interrogator-cli.py --target https://example.com/mcp --fuzz

    # With rate limiting
    python agent_fuzzer_cli_addon.py --profile profile.json --target https://example.com/mcp --rate-limit 3

    # Limit payloads per parameter (for faster testing)
    python agent_fuzzer_cli_addon.py --profile profile.json --target https://example.com/mcp --max-payloads 10

ENVIRONMENT VARIABLES:
    MCP_AUTH_TOKEN:     Optional. Bearer token for MCP server authentication
    HF_TOKEN:           Optional. HuggingFace token (alternative to MCP_AUTH_TOKEN)
    http_proxy:         Optional. HTTP proxy URL
    https_proxy:        Optional. HTTPS proxy URL

EXIT CODES:
    0:  Success
    1:  General error
    2:  Missing required arguments
    3:  Profile file not found
    4:  MCP connection failed
    5:  Fuzzing failed
"""

import argparse
import asyncio
import json
import os
import sys
from pathlib import Path
from typing import Dict, Optional

import httpx
from dotenv import load_dotenv
from mcp import ClientSession
from mcp.client.streamable_http import streamablehttp_client
from rich.console import Console
from rich.panel import Panel
from rich.progress import (
    BarColumn,
    Progress,
    SpinnerColumn,
    TextColumn,
    TimeElapsedColumn,
)
from rich.table import Table

from agent_interrogator.fuzzing_module import FuzzingEngine
from agent_interrogator.models import AgentProfile

# Load environment variables
load_dotenv(override=True)

# Rich console for colored output
console = Console()

# Exit codes
EXIT_SUCCESS = 0
EXIT_GENERAL_ERROR = 1
EXIT_MISSING_ARGS = 2
EXIT_PROFILE_NOT_FOUND = 3
EXIT_MCP_CONNECTION_FAILED = 4
EXIT_FUZZING_FAILED = 5


def load_agent_profile(filepath: str) -> AgentProfile:
    """Load AgentProfile from JSON file.

    Args:
        filepath: Path to AgentProfile JSON file

    Returns:
        AgentProfile object

    Exits:
        EXIT_PROFILE_NOT_FOUND if file doesn't exist or is invalid
    """
    if not os.path.exists(filepath):
        console.print(
            Panel(
                f"[red]Profile file not found:[/red] {filepath}\n\n"
                "[bold]Expected:[/bold]\n"
                "A JSON file generated by the Agent Interrogator CLI tool.\n\n"
                "[bold]To generate a profile:[/bold]\n"
                "  python agent-interrogator-cli.py --target https://example.com/mcp --output json",
                title="File Not Found",
                border_style="red",
            )
        )
        sys.exit(EXIT_PROFILE_NOT_FOUND)

    try:
        with open(filepath, "r") as f:
            data = json.load(f)

        # Handle wrapped format ({"target": "...", "profile": "..."})
        # or direct AgentProfile format
        if "profile" in data and isinstance(data["profile"], str):
            # Profile is a string, try to parse it
            # This is the format from save_output() in main CLI
            console.print(
                "[yellow]Warning: Profile is stored as string, attempting to parse...[/yellow]"
            )
            # For now, we'll need the profile to be in proper JSON format
            console.print(
                Panel(
                    "[red]Invalid profile format[/red]\n\n"
                    "The profile file contains a string representation instead of structured JSON.\n\n"
                    "[bold]To fix:[/bold]\n"
                    "Re-run the Agent Interrogator and save the profile in proper JSON format,\n"
                    "or use the --fuzz flag directly with the main CLI.",
                    title="Format Error",
                    border_style="red",
                )
            )
            sys.exit(EXIT_PROFILE_NOT_FOUND)

        # Try to load as AgentProfile
        if "capabilities" in data:
            profile = AgentProfile(**data)
        elif "profile" in data and "capabilities" in data["profile"]:
            profile = AgentProfile(**data["profile"])
        else:
            raise ValueError("Invalid AgentProfile format")

        return profile

    except (json.JSONDecodeError, ValueError) as e:
        console.print(
            Panel(
                f"[red]Failed to load profile file[/red]\n\n"
                f"Error: {str(e)}\n\n"
                "[bold]Expected format:[/bold]\n"
                'JSON file with "capabilities" array containing discovered functions.',
                title="Parse Error",
                border_style="red",
            )
        )
        sys.exit(EXIT_PROFILE_NOT_FOUND)


async def connect_to_mcp(
    server_url: str,
    auth_token: Optional[str],
    timeout: int,
    use_proxy: bool
) -> ClientSession:
    """Connect to MCP server and return session.

    Args:
        server_url: MCP server URL
        auth_token: Optional authentication token
        timeout: Connection timeout
        use_proxy: Whether to use proxy and disable SSL verification

    Returns:
        Connected ClientSession

    Exits:
        EXIT_MCP_CONNECTION_FAILED on connection errors
    """
    console.print(f"[cyan]Connecting to MCP server at {server_url}...[/cyan]")

    try:
        # Prepare headers
        headers = {}
        if auth_token:
            headers["Authorization"] = f"Bearer {auth_token}"
            console.print("[green]Using Bearer token authentication[/green]")

        # Create httpx client factory if needed
        client_factory = None
        if use_proxy:
            console.print("[yellow]SSL verification disabled for proxy interception[/yellow]")

            def insecure_client_factory(
                headers: Optional[Dict[str, str]] = None,
                timeout: Optional[httpx.Timeout] = None,
                auth: Optional[httpx.Auth] = None,
            ) -> httpx.AsyncClient:
                if timeout is None:
                    timeout = httpx.Timeout(30)
                return httpx.AsyncClient(
                    verify=False,
                    headers=headers,
                    timeout=timeout,
                    auth=auth,
                    http1=True,
                    http2=False,
                )

            client_factory = insecure_client_factory

        # Establish connection
        if client_factory:
            streams_context = streamablehttp_client(
                url=server_url,
                headers=headers,
                timeout=timeout,
                httpx_client_factory=client_factory,
            )
        else:
            streams_context = streamablehttp_client(
                url=server_url,
                headers=headers,
                timeout=timeout
            )

        streams = await streams_context.__aenter__()
        read_stream, write_stream, get_session_id = streams

        # Create session
        session_context = ClientSession(read_stream, write_stream)
        session = await session_context.__aenter__()

        # Initialize
        init_result = await session.initialize()

        # Extract server info
        server_name = "Unknown"
        server_version = "Unknown"
        if hasattr(init_result, "serverInfo"):
            server_name = getattr(init_result.serverInfo, "name", "Unknown")
            server_version = getattr(init_result.serverInfo, "version", "Unknown")

        console.print(f"[green]Connected to: {server_name} v{server_version}[/green]")

        return session

    except Exception as e:
        console.print(
            Panel(
                f"[red]Failed to connect to MCP server[/red]\n\n"
                f"URL: {server_url}\n"
                f"Error: {str(e)}\n\n"
                "[bold]Troubleshooting:[/bold]\n"
                "- Verify the target URL is correct\n"
                "- Check if authentication is required (use MCP_AUTH_TOKEN)\n"
                "- Ensure the MCP server is running and accessible",
                title="Connection Error",
                border_style="red",
            )
        )
        sys.exit(EXIT_MCP_CONNECTION_FAILED)


def display_results(engine: FuzzingEngine) -> None:
    """Display fuzzing results in formatted output.

    Args:
        engine: FuzzingEngine with completed results
    """
    summary = engine.get_vulnerability_summary()

    # Summary panel
    console.print()
    console.print(
        Panel(
            f"[bold]Total Tests:[/bold] {summary['total_tests']}\n"
            f"[bold]Vulnerabilities Found:[/bold] {summary['total_vulnerabilities']}\n"
            f"[bold]Vulnerable Functions:[/bold] {summary['vulnerable_functions']} / {summary['targets_tested']}",
            title="[bold green]Fuzzing Complete[/bold green]",
            border_style="green",
        )
    )
    console.print()

    # Vulnerability breakdown
    if summary['vulnerability_breakdown']:
        console.print("[bold cyan]Vulnerability Breakdown:[/bold cyan]")
        table = Table(show_header=True)
        table.add_column("Vulnerability Type", style="cyan")
        table.add_column("Count", style="yellow", justify="right")

        for vuln_type, count in summary['vulnerability_breakdown'].items():
            table.add_row(vuln_type, str(count))

        console.print(table)
        console.print()

    # High priority findings
    if summary['high_priority_findings']:
        console.print("[bold red]High Priority Findings:[/bold red]")
        for i, finding in enumerate(summary['high_priority_findings'][:10], 1):
            console.print(f"  {i}. [cyan]{finding['function']}[/cyan]")
            console.print(f"     Parameter: {finding['parameter']}")
            console.print(f"     Flags: {', '.join(finding['flags'])}")
            console.print()

        if len(summary['high_priority_findings']) > 10:
            console.print(f"  ... and {len(summary['high_priority_findings']) - 10} more")
            console.print()


def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Agent Fuzzer - MCP Security Validation Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Fuzz using existing profile
  %(prog)s --profile agent-profile-example.com.json --target https://example.com/mcp

  # With rate limiting
  %(prog)s --profile profile.json --target https://example.com/mcp --rate-limit 3

  # Limit payloads per parameter
  %(prog)s --profile profile.json --target https://example.com/mcp --max-payloads 10

Environment Variables:
  MCP_AUTH_TOKEN    Optional. Bearer token for MCP authentication
  HF_TOKEN          Optional. HuggingFace token (alternative to MCP_AUTH_TOKEN)
  http_proxy        Optional. HTTP proxy URL
  https_proxy       Optional. HTTPS proxy URL
        """,
    )

    parser.add_argument(
        "--profile",
        required=True,
        help="Path to AgentProfile JSON file from Agent Interrogator",
    )

    parser.add_argument(
        "--target",
        required=True,
        help="MCP server endpoint URL (e.g., https://example.com/mcp)",
    )

    parser.add_argument(
        "--rate-limit",
        type=float,
        default=0.0,
        help="Delay in seconds between MCP requests (default: 0)",
    )

    parser.add_argument(
        "--max-payloads",
        type=int,
        help="Maximum payloads to test per parameter (default: all)",
    )

    parser.add_argument(
        "--timeout",
        type=int,
        default=30,
        help="MCP connection timeout in seconds (default: 30)",
    )

    parser.add_argument(
        "--output",
        help="Output format(s): json, markdown, or both (comma-separated)",
    )

    parser.add_argument(
        "--proxy",
        action="store_true",
        help="Enable proxy support (requires http_proxy/https_proxy env vars)",
    )

    parser.add_argument(
        "--allow-destructive",
        action="store_true",
        help="Allow potentially destructive payloads (USE WITH CAUTION)",
    )

    return parser.parse_args()


async def main():
    """Main CLI entry point."""
    args = parse_arguments()

    # Display banner
    console.print(
        Panel(
            "[bold cyan]Agent Fuzzer CLI[/bold cyan]\n"
            "MCP Security Validation through Parameter-Aware Fuzzing",
            border_style="cyan",
        )
    )
    console.print()

    # Load agent profile
    console.print(f"[cyan]Loading AgentProfile from:[/cyan] {args.profile}")
    profile = load_agent_profile(args.profile)
    console.print(f"[green]Loaded {len(profile.capabilities)} capabilities[/green]")
    console.print()

    # Get auth token
    auth_token = os.getenv("MCP_AUTH_TOKEN") or os.getenv("HF_TOKEN")
    if auth_token:
        console.print("[green]Found MCP authentication token in environment[/green]")
    else:
        console.print("[yellow]No MCP authentication token found[/yellow]")

    # Check proxy
    http_proxy = os.getenv("http_proxy") or os.getenv("HTTP_PROXY")
    https_proxy = os.getenv("https_proxy") or os.getenv("HTTPS_PROXY")
    use_proxy = args.proxy and bool(http_proxy or https_proxy)

    if use_proxy:
        console.print("[green]Proxy enabled[/green]")

    console.print()

    # Connect to MCP server
    session = await connect_to_mcp(
        server_url=args.target,
        auth_token=auth_token,
        timeout=args.timeout,
        use_proxy=use_proxy
    )

    try:
        # Initialize fuzzing engine
        console.print("[cyan]Initializing fuzzing engine...[/cyan]")
        engine = FuzzingEngine(
            agent_profile=profile,
            mcp_session=session,
            rate_limit_delay=args.rate_limit,
            non_destructive=not args.allow_destructive,
            max_payloads_per_param=args.max_payloads,
        )

        # Map targets
        targets = engine.map_targets()
        console.print(f"[green]Mapped {len(targets)} fuzzing targets[/green]")
        console.print()

        # Calculate total tests
        total_functions = len(targets)
        console.print(
            Panel(
                f"[bold yellow]Starting Fuzzing Operation[/bold yellow]\n\n"
                f"Functions to test: {total_functions}\n"
                f"Rate limit: {args.rate_limit}s per request\n"
                f"Mode: {'DESTRUCTIVE' if args.allow_destructive else 'NON-DESTRUCTIVE'}",
                border_style="yellow",
            )
        )
        console.print()

        # Run fuzzing with progress bar
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
            TimeElapsedColumn(),
            console=console,
        ) as progress:
            task = progress.add_task(
                "[cyan]Fuzzing MCP functions...",
                total=total_functions
            )

            for target in targets:
                progress.update(
                    task,
                    description=f"[cyan]Fuzzing {target.get_full_name()}..."
                )
                await engine.fuzz_target(target)
                progress.advance(task)

        # Display results
        display_results(engine)

        # Export results
        if args.output:
            from urllib.parse import urlparse

            parsed = urlparse(args.target)
            hostname = parsed.hostname or "unknown"
            output_formats = [fmt.strip().lower() for fmt in args.output.split(",")]

            for fmt in output_formats:
                if fmt == "json":
                    filename = f"fuzz-results-{hostname}.json"
                    engine.export_results(filename, format="json")
                    console.print(f"[green]Exported JSON results to:[/green] {filename}")
                elif fmt == "markdown":
                    filename = f"fuzz-results-{hostname}.md"
                    engine.export_results(filename, format="markdown")
                    console.print(f"[green]Exported Markdown results to:[/green] {filename}")

        return EXIT_SUCCESS

    except Exception as e:
        console.print()
        console.print(
            Panel(
                f"[bold red]FUZZING FAILED[/bold red]\n\n{str(e)}",
                border_style="red",
            )
        )
        import traceback
        traceback.print_exc()
        return EXIT_FUZZING_FAILED

    finally:
        console.print()
        console.print("[cyan]Cleaning up...[/cyan]")
        # Note: Session cleanup would happen here in production
        console.print("[green]Done![/green]")


if __name__ == "__main__":
    try:
        exit_code = asyncio.run(main())
        sys.exit(exit_code)
    except KeyboardInterrupt:
        console.print("\n[yellow]Interrupted by user[/yellow]")
        sys.exit(EXIT_GENERAL_ERROR)
    except Exception as e:
        console.print(f"\n[red]Fatal error: {e}[/red]")
        import traceback
        traceback.print_exc()
        sys.exit(EXIT_GENERAL_ERROR)